1. Le Moteur de Synchronisation Silencieuse
Remplace ta logique de récupération par celle-ci. Elle ne touche pas au DOM si rien n'a changé.
// On garde en mémoire les IDs des messages déjà affichés
let displayedMessageIds = new Set();

async function syncChatSilently() {
    if (!activePeer || !user) return;

    try {
        const res = await fetch(`${API}/messages`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: activePeer.tfid })
        });
        
        const messages = await res.json();
        const container = document.getElementById('chat-messages');
        
        // On filtre uniquement les messages qui ne sont pas "ok" 
        // ET qui n'ont pas encore été affichés (ceux qui n'existent pas dans notre Set)
        const newMessages = messages.filter(m => {
            const msgId = m.time + m.from; // Identifiant unique basé sur temps + expéditeur
            return m.text !== 'ok' && !displayedMessageIds.has(msgId);
        });

        if (newMessages.length > 0) {
            // Détecter si l'utilisateur est en train de lire en haut
            const isAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 150;

            newMessages.forEach(m => {
                const msgId = m.time + m.from;
                displayedMessageIds.add(msgId); // On le marque comme "existant"
                
                // On l'ajoute au DOM tout en bas
                appendMessageToDOM(m);
            });

            // On ne scrolle que si l'utilisateur n'est pas en train de remonter le chat
            if (isAtBottom) {
                scrollToBottom();
            }
        }
        
        // Mise à jour des status (Checkmarks) sans toucher au texte
        updateCheckmarks(messages);

    } catch (e) {
        // En silence total
    }
}

2. La fonction d'ajout (Append) propre
Cette fonction crée l'élément et l'injecte sans vider le container.
function appendMessageToDOM(m) {
    const container = document.getElementById('chat-messages');
    const isMe = m.from === user.tfid;
    
    const div = document.createElement('div');
    div.className = `bubble ${isMe ? 'me' : 'them'} animate-slide-in`; // Ajoute une petite animation
    div.id = `msg-${m.time.replace(/[^a-zA-Z0-9]/g, '-')}`;
    
    // Rendu du texte (sécurisé ou media)
    div.innerHTML = renderText(m.text);
    
    if (isMe) {
        const status = document.createElement('span');
        status.className = 'status';
        status.innerText = m.read ? '✓✓' : '✓';
        if (m.read) status.classList.add('read');
        div.appendChild(status);
    }

    addMessageListeners(div, m.text);
    container.appendChild(div);
}

3. CSS pour l'apparition fluide (Style Pro)
Pour que l'utilisateur ne remarque pas un "saut" brusque, ajoute cette animation dans ton <style> :
@keyframes slideIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.animate-slide-in {
    animation: slideIn 0.3s cubic-bezier(0.1, 0.9, 0.2, 1);
}

4. Réinitialisation lors du changement de contact
Quand tu changes de contact (clic sur un autre peer), tu dois vider le Set pour que les nouveaux messages s'affichent.
function resetChatView() {
    displayedMessageIds.clear(); // Vide le stockage local de la session
    document.getElementById('chat-messages').innerHTML = ''; // Vide l'écran
    currentChatMessages = [];
}

Les bénéfices de cette méthode :
 * Invisible : L'utilisateur peut continuer à écrire ou scroller en haut, les nouveaux messages se glissent discrètement en bas de la pile.
 * Ultra-léger : Le CPU du téléphone ne travaille que sur 1 ou 2 nouveaux messages au lieu de recalculer 200 messages à chaque fois.
 * Aucun clignotement : Comme on ne fait pas de .innerHTML = '', l'écran ne devient jamais blanc, même pendant une milliseconde.
