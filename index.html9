<!DOCTYPE html>
<html lang="ht">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes, viewport-fit=cover">
    
    <title>D'H7 | Digital Hub 7</title>
    <meta name="description" content="D'H7 (Digital Hub 7) se yon platfòm kominikasyon sekirize ki pèmèt ou jere idantite dijital ou ak yon TFID/D'H7 inik. Konekte kounye a pou w jwenn aksè nan yon rezo pwoteje, miltiling (Kreyòl, Fransè, Angle, Espanyòl), epi fasil pou itilize.">

    <link rel="icon" type="image/png" href="https://www.adamdh7.org/asset/IMG_7023.png">
    <link rel="shortcut icon" href="https://www.adamdh7.org/asset/IMG_7023.png">
    <link rel="canonical" href="https://www.adamdh7.org/" />
    <link rel="apple-touch-icon" href="https://www.adamdh7.org/asset/IMG_7023.png" />

    <meta property="og:title" content="D'H7 - Digital Hub 7">
    <meta property="og:description" content="Konekte sou D'H7 pou yon eksperyans dijital sekirize.">
    <meta property="og:image" content="https://www.adamdh7.org/asset/IMG_7023.png">
    <meta property="og:url" content="https://www.adamdh7.org">
    <meta property="og:type" content="website">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "D'H7",
      "alternateName": "Digital Hub 7",
      "url": "https://www.adamdh7.org",
      "logo": "https://www.adamdh7.org/asset/IMG_7023.png"
    }
    </script>

    <link rel="manifest" href="manifest.json" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        :root {
            --bg-pure: #000000;
            --bg-card: #0a0a0a;
            --bg-input: #1c1c1e;
            --accent: #007aff;
            --border: #1a1a1a;
            --text-dim: #8e8e93;
            --msg-me: #007aff;
            --msg-them: #262628;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-pure);
            color: white;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
        }

        /* Scroll fixes for cross-browser (Android/Chrome/Edge + iOS/Safari) */
        .scroll-container {
            overflow-y: auto;
            touch-action: pan-y;
            overscroll-behavior-y: contain;
            scroll-behavior: smooth;
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }
        
        .scroll-container::-webkit-scrollbar { width: 0; display: none; }
        .scroll-container {
            height: 100%;
            max-height: 100%;
        }

        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-pure);
            z-index: 10;
            transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1), opacity 0.2s; /* iOS slide transition */
        }

        .screen.hidden-left { transform: translateX(-30%); opacity: 0; pointer-events: none; } /* Parallax effect */
        .screen.hidden-right { transform: translateX(100%); opacity: 1; pointer-events: none; } /* Slide in from right */
        .screen.active { transform: translateX(0); opacity: 1; pointer-events: auto; }

        .ios-header {
            padding: env(safe-area-inset-top) 1rem 0.8rem 1rem;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            position: sticky;
            top: 0;
            z-index: 20;
            border-bottom: 0.5px solid rgba(255,255,255,0.1);
        }

        /* Chat Layout */
        .chat-body {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 2px; /* WhatsApp style gap */
        }

        .bubble {
            max-width: 85%; /* Wider like WhatsApp for voice */
            padding: 0.5rem 0.8rem;
            font-size: 1rem;
            line-height: 1.4;
            position: relative;
            white-space: pre-wrap;
            word-break: break-word;
            margin-bottom: 2px;
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }

        .bubble.me {
            align-self: flex-end;
            background-color: var(--msg-me);
            color: white;
            border-radius: 12px 12px 0 12px;
        }

        .bubble.them {
            align-self: flex-start;
            background-color: var(--msg-them);
            color: white;
            border-radius: 12px 12px 12px 0;
        }

        /* Media Support Styles */
        .media-content {
            border-radius: 8px;
            overflow: hidden;
            margin-top: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            position: relative;
        }
        .media-content img, .media-content video {
            max-width: 100%;
            height: auto;
            display: block;
        }
        .media-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
        }
        .fullscreen-media {
            position: fixed;
            inset: 0;
            background: black;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            overflow: auto;
        }
        .fullscreen-media img {
            width: 100%;
            height: auto;
            max-width: none;
            max-height: none;
            touch-action: pinch-zoom;
        }
        .fullscreen-media video {
            max-width: 100%;
            max-height: 90%;
            object-fit: contain;
        }
        .fullscreen-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            cursor: pointer;
            z-index: 10000;
        }
        .fullscreen-media audio {
            width: 80%;
            margin: 20px auto;
        }

        /* File Link Style */
        .file-link {
            color: #66e0ff;
            text-decoration: underline;
            cursor: pointer;
        }

        /* Reply Styles */
        .reply-bar {
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 4px 8px;
            margin-bottom: 4px;
            font-size: 0.75rem;
            border-left: 3px solid rgba(255,255,255,0.5);
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }
        .reply-name { font-weight: 700; color: rgba(255,255,255,0.9); margin-bottom: 2px; }
        .reply-text { color: rgba(255,255,255,0.7); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        .status {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.6);
            display: inline-block;
            float: right;
            margin-left: 8px;
            margin-top: 4px;
        }
        .status.read { color: #66e0ff; }

        /* Input Area - WhatsApp Style */
        .input-area {
            padding: 0.5rem 0.5rem calc(0.5rem + env(safe-area-inset-bottom)) 0.5rem;
            background: var(--bg-pure);
            display: flex;
            align-items: flex-end;
            gap: 0.5rem;
            border-top: 0.5px solid rgba(255,255,255,0.1);
        }

        .input-wrapper {
            flex: 1;
            background: var(--bg-input);
            border-radius: 20px;
            display: flex;
            align-items: flex-end;
            padding: 8px 12px;
            min-height: 40px;
        }

        #msg-input {
            width: 100%;
            background: transparent;
            border: none;
            color: white;
            outline: none;
            font-size: 1rem;
            max-height: 100px;
            resize: none;
            padding: 0;
            line-height: 1.4;
        }

        .action-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: var(--msg-me);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            flex-shrink: 0;
            transition: all 0.2s;
            cursor: pointer;
        }
        .action-btn.mic-mode { background: var(--msg-them); }

        .icon-btn {
            color: var(--accent);
            padding: 5px;
            cursor: pointer;
        }

        /* Voice Recorder UI */
        #recording-ui {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ff3b30;
            font-weight: 600;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* Helpers */
        .hidden { display: none !important; }
        .copyable { cursor: pointer; }
        .contact-card {
            background: transparent;
            padding: 0.8rem 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            border-bottom: 0.5px solid rgba(255,255,255,0.05);
        }
        .contact-card:active { background: rgba(255,255,255,0.05); }
        .avatar {
            width: 3.2rem;
            height: 3.2rem;
            background: #2c2c2e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 1.1rem;
            color: white;
        }
        
        .modern-input {
            background: var(--bg-input);
            border: none;
            border-radius: 12px;
            padding: 12px;
            color: white;
            width: 100%;
            outline: none;
        }

        /* Language Overlay Bottom Sheet */
        .language-overlay {
            position: fixed;
            bottom: 0; left: 0; width: 100%;
            background: #1c1c1e;
            border-radius: 20px 20px 0 0;
            padding: 20px;
            z-index: 100;
            transform: translateY(100%);
            transition: transform 0.3s;
        }
        .language-overlay.show { transform: translateY(0); }
        .lang-opt {
            padding: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); text-align: center;
        }
        .backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 99; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .backdrop.show { opacity: 1; pointer-events: auto; }
        
        #scroll-down-btn {
            position: fixed; bottom: 80px; right: 20px;
            background: #262628; border: 1px solid #333; color: var(--accent);
            padding: 8px; border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 30; transition: opacity 0.3s;
        }

        .unread-badge {
            background: #007aff;
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 20px;
            text-align: center;
        }

        #copy-menu {
            position: absolute;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            z-index: 100;
            flex-direction: column;
            gap: 0.5rem;
        }

        #preview-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 99;
        }

        #contact-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1.25rem;
            padding: 1.25rem;
            max-width: 90%;
            max-height: 70%;
            overflow-y: auto;
            z-index: 100;
        }

        .mini-chat {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .mini-bubble {
            max-width: 80%;
            padding: 0.6rem 0.8rem;
            font-size: 0.8rem;
            line-height: 1.3;
            position: relative;
            white-space: pre-wrap;
            word-break: break-word;
            border-radius: 1rem;
        }

        .mini-bubble.me {
            align-self: flex-end;
            background-color: #007aff;
            color: white;
            border-radius: 1rem 1rem 0.15rem 1rem;
        }

        .mini-bubble.them {
            align-self: flex-start;
            background-color: #1c1c1e;
            color: white;
            border-radius: 1rem 1rem 1rem 0.15rem;
            border: 1px solid var(--border);
        }

        .file-preview {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .file-icon {
            font-size: 24px;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animate-slide-in {
            animation: slideIn 0.3s cubic-bezier(0.1, 0.9, 0.2, 1);
        }

        .bubble.me audio {
            background-color: var(--msg-me);
            color: white;
            border-radius: 10px;
        }

        .bubble.them audio {
            background-color: var(--msg-them);
            color: white;
            border-radius: 10px;
        }

        audio {
            width: 100%;
            height: 30px; /* Same size */
        }

        .reply-preview {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .reply-preview img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
        }

        .reply-preview i {
            font-size: 20px;
            color: var(--accent);
        }

        .reply-preview span {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        /* Updated Voice Player (WhatsApp iOS Style) */
        .voice-player {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0; /* No background padding, integrates into bubble */
            width: auto; /* Fits bubble width */
            max-width: 250px; /* Typical WhatsApp size */
        }
        .play-pause {
            cursor: pointer;
            width: 20px;
            height: 20px;
        }
        .progress-bar {
            flex: 1;
            height: 4px;
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        .wave-form {
            position: absolute;
            height: 100%;
            width: 100%;
            display: flex;
            gap: 1px; /* Tighter for more bars */
        }
        .wave-bar {
            width: 2px;
            background: rgba(255,255,255,0.3); /* Default gray */
            border-radius: 2px; /* Rounded like WhatsApp */
        }
        .bubble.me .wave-bar {
            background: rgba(255,255,255,0.8); /* White in blue bubble */
        }
        .bubble.them .wave-bar.progressed {
            background: var(--accent); /* Blue progress in gray bubble */
        }
        .bubble.me .wave-bar.progressed {
            background: white; /* White progress in blue bubble */
        }
        .seeker {
            position: absolute;
            top: -4px;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            transform: translateX(-50%);
        }
        .time-display {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.7);
            min-width: 30px;
            display: block; /* Always shown */
        }
        .speed-control {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            margin-left: 4px;
        }

        #upload-loading {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            color: white;
            font-size: 1.2rem;
        }
    </style>
</head>
<body>

    <section id="scr-auth" class="screen active items-center justify-center p-8">
        <div class="w-full max-w-sm text-center">
            <h1 class="text-7xl font-black tracking-tighter mb-2 italic logo" data-key="logo" onclick="showLang()">D'H7</h1>
            <p class="text-zinc-600 text-xs uppercase tracking-[0.6em] mb-16" data-key="subtitle">Digital HUB 7</p>
            
            <div id="login-form" class="space-y-4">
                <input type="text" id="login-id" data-key="placeholder-tfid" placeholder="TFID oswa DH7" class="modern-input py-5">
                <input type="password" id="login-pass" data-key="placeholder-password" placeholder="Modpas" class="modern-input py-5">
                <button onclick="login()" class="w-full bg-white text-black font-black py-5 rounded-2xl mt-4 text-lg" data-key="connect">LOG IN</button>
                <button onclick="toggleAuth()" class="w-full text-zinc-500 text-sm mt-4" data-key="register">KREYE YON KONT</button>
            </div>

            <div id="reg-form" class="hidden space-y-4">
                <div class="flex gap-2">
                    <input type="text" id="reg-nom" data-key="placeholder-lastname" placeholder="Nom" class="modern-input">
                    <input type="text" id="reg-prenom" data-key="placeholder-firstname" placeholder="Prenom" class="modern-input">
                </div>
                <input type="text" id="reg-dh7" data-key="placeholder-dh7" placeholder="DH7 ID (ex: adamdh7@dh7.tf)" class="modern-input">
                <input type="number" id="reg-age" data-key="placeholder-age" placeholder="Laj" class="modern-input">
                <input type="password" id="reg-pass" data-key="placeholder-password" placeholder="Modpas" class="modern-input">
                <button onclick="register()" class="w-full bg-white text-black font-black py-5 rounded-2xl mt-4" data-key="create-account">JOIN D'H7</button>
                <button onclick="toggleAuth()" class="w-full text-zinc-500 text-sm mt-4" data-key="back-to-login">RETOUNEN</button>
            </div>
        </div>
    </section>

    <section id="scr-home" class="screen hidden-right">
        <header class="ios-header flex justify-between items-end">
            <div>
                <h2 class="text-4xl font-black tracking-tighter logo" data-key="logo" onclick="showLang()">Mesaj</h2>
            </div>
            <div class="flex gap-6 pb-1">
                <button onclick="navTo('scr-search')">
                    <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                </button>
                <button onclick="navTo('scr-menu')">
                    <svg class="w-7 h-7" fill="currentColor" viewBox="0 0 20 20"><path d="M6 10a2 2 0 11-4 0 2 2 0 014 0zM12 10a2 2 0 11-4 0 2 2 0 014 0zM18 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                </button>
            </div>
        </header>
        
        <div id="contact-list" class="flex-1 overflow-y-auto p-6 custom-scroll scroll-container">
        </div>
    </section>

    <section id="scr-chat" class="screen hidden-right">
        <header class="ios-header flex items-center gap-4">
            <button onclick="navTo('scr-home')" class="p-1">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M15 19l-7-7 7-7"></path></svg>
            </button>
            <div class="flex-1 min-w-0">
                <h3 id="chat-peer-name" class="font-bold text-lg leading-none truncate">---</h3>
                <p id="chat-peer-tfid" class="text-[10px] text-zinc-500 mt-1 tracking-widest uppercase truncate copyable" onclick="copyToClipboard(this.innerText)">---</p>
            </div>
        </header>

        <div id="chat-messages" class="chat-container chat-body scroll-container">
        </div>

        <div id="reply-preview" class="hidden mx-2 mt-2 bg-zinc-800 p-2 rounded-lg border-l-4 border-blue-500 flex justify-between items-center">
            <div class="overflow-hidden flex items-center">
                <div id="reply-media-preview"></div>
                <div>
                    <p class="text-xs text-blue-400 font-bold" id="reply-to-name">Répondre à...</p>
                    <p class="text-xs text-gray-300 truncate" id="reply-content"></p>
                </div>
            </div>
            <button onclick="cancelReply()" class="text-gray-400 px-2">×</button>
        </div>

        <div class="input-area">
            <button class="icon-btn text-blue-500" onclick="document.getElementById('file-input').click()">
                <i class="fa-solid fa-plus text-xl"></i>
            </button>
            <input type="file" id="file-input" class="hidden" accept="image/*,video/*,audio/*" onchange="handleFileSelect(this)">

            <div class="input-wrapper transition-all duration-200" id="input-wrapper">
                <div id="recording-ui" class="hidden flex-1">
                    <i class="fa-solid fa-circle text-xs"></i> <span>Enregistrement... <span id="rec-timer">0:00</span></span>
                </div>
                <textarea id="msg-input" data-key="message-placeholder" placeholder="" rows="1" oninput="handleInput(this)"></textarea>
            </div>

            <div id="action-btn" class="action-btn mic-mode">
                <i class="fa-solid fa-microphone text-lg" id="action-icon"></i>
            </div>
        </div>

        <div id="scroll-down-btn" class="hidden" onclick="scrollToBottom()">
            <svg class="w-6 h-6" fill="none" stroke="white" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"></path>
            </svg>
        </div>
    </section>

    <section id="scr-search" class="screen hidden-right">
        <header class="ios-header flex items-center gap-4">
            <input type="text" id="search-q" oninput="doSearch()" data-key="search-placeholder" placeholder="Chèche nan D'H7..." class="flex-1 modern-input">
            <button onclick="navTo('scr-home')" class="text-sm font-bold text-zinc-400" data-key="close">ANILE</button>
        </header>
        <div id="search-results" class="flex-1 overflow-y-auto p-6 scroll-container">
        </div>
    </section>

    <section id="scr-menu" class="screen hidden-right">
        <div class="flex-1 flex flex-col items-center justify-center p-10 text-center">
            <div class="w-24 h-24 bg-zinc-900 rounded-full mb-4 flex items-center justify-content: center text-4xl font-black border border-zinc-800" id="m-init">?</div>
            <h2 id="m-name" class="text-4xl font-black mb-1">---</h2>
            <p id="m-dh7" class="text-zinc-500 font-mono mb-4 copyable" onclick="copyToClipboard(this.innerText)">---</p>
            
            <div class="w-full max-w-xs space-y-4">
                <div class="p-6 bg-zinc-900 rounded-3xl border border-zinc-800 text-left">
                    <p class="text-[10px] text-zinc-600 font-black uppercase tracking-widest mb-2" data-key="personal-tfid">TFID Sekirize</p>
                    <p id="m-tfid" class="text-xl font-mono text-white copyable" onclick="copyToClipboard(this.innerText)">---</p>
                </div>
                <button onclick="showLang()" class="w-full py-5 text-white font-black tracking-widest bg-zinc-900/50 rounded-2xl border border-zinc-800" data-key="language">LANGUE</button>
                <button onclick="logout()" class="w-full py-5 text-red-500 font-black tracking-widest bg-red-500/5 rounded-2xl border border-red-500/10" data-key="logout">DEKONEKTE</button>
                <button onclick="navTo('scr-home')" class="w-full py-5 text-zinc-500 font-bold" data-key="close">RETOUNEN</button>
            </div>
        </div>
    </section>

    <div id="backdrop" class="backdrop" onclick="closeOverlays()"></div>
    <div id="lang-sheet" class="language-overlay">
        <div class="lang-opt" onclick="changeLanguage('ht')">Kreyòl Ayisyen</div>
        <div class="lang-opt" onclick="changeLanguage('fr')">Français</div>
        <div class="lang-opt" onclick="changeLanguage('en')">English</div>
        <div class="lang-opt" onclick="changeLanguage('es')">Español</div>
        <div class="p-4 text-center text-blue-500 font-bold cursor-pointer" onclick="closeOverlays()">Fermer</div>
    </div>
    
    <div id="fs-media" class="hidden fullscreen-media">
        <svg class="fullscreen-close w-8 h-8" onclick="closeFullscreen()" fill="none" stroke="white" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
    </div>

    <div id="preview-overlay" class="hidden" onclick="hideContactPreview()"></div>
    <div id="contact-preview" class="hidden"></div>
    <div id="copy-menu" class="hidden flex flex-col gap-2">
        <button id="copy-btn" data-key="copy"></button>
        <button id="reply-btn" data-key="reply"></button>
    </div>

    <div id="upload-loading" class="hidden">
        <p data-key="loading">Patiyans tanpri...</p>
    </div>

    <script>
        const API = "https://dh7.adamdh7.org";
        const UPLOAD_URL = "https://uploads.adamdh7.org/";
        const PUBLIC_URL = "https://uploads.adamdh7.org/";
        let user = JSON.parse(localStorage.getItem('dh7_session')) || null;
        let activePeer = null;
        let chatInterval = null;
        let homeInterval = null;
        let lastViewed = JSON.parse(localStorage.getItem('lastViewed')) || {};
        let currentLanguage = localStorage.getItem('language');
        if (!currentLanguage) {
            const browserLang = navigator.language.split('-')[0];
            if (['fr', 'en', 'es'].includes(browserLang)) {
                currentLanguage = browserLang;
            } else {
                currentLanguage = 'ht';
            }
            localStorage.setItem('language', currentLanguage);
        }
        let shownTfids = new Set();
        let replyingTo = null;
        const REPLY_START = '\u2063'; // Invisible separator for start of reply
        const REPLY_END = '\u2064'; // Invisible separator for end of reply
        let displayedMessageIds = new Set();
        const translations = {
            ht: {
                logo: "D'H7",
                subtitle: "Digital HUB 7",
                "placeholder-tfid": "TFID oswa DH7",
                "placeholder-password": "Modpas",
                connect: "Konekte",
                register: "KREYE YON KONT",
                "placeholder-lastname": "Nom",
                "placeholder-firstname": "Prenom",
                "placeholder-dh7": "DH7 ID (ex: adamdh7@dh7.tf)",
                "placeholder-age": "Laj",
                "create-account": "JOIN D'H7",
                "back-to-login": "RETOUNEN",
                "search-placeholder": "Chèche nan D'H7...",
                "personal-tfid": "TFID Sekirize",
                language: "LANGUE",
                logout: "DEKONEKTE",
                close: "ANILE",
                "message-placeholder": "Ekri yon mesaj...",
                no_users: "Pa gen moun nan D'H7 pako.",
                no_results: "PA JWENN ITILIZATÈ SA",
                start_chat: "Klike pou kòmanse pale...",
                no_contacts: "Pa gen kontak pako. Chèche moun pou kòmanse pale.",
                copy: "Kopi",
                reply: "Reponn",
                copied: "Kopi",
                you: "Ou",
                "image-message": "Imaj",
                "voice-message": "Mesaj vwa",
                "file-message": "Fichye",
                "loading": "Patiyans tanpri...",
                "upload_failed": "Echèk upload apre plizyè esè"
            },
            fr: {
                logo: "D'H7",
                subtitle: "Digital HUB 7",
                "placeholder-tfid": "TFID ou DH7",
                "placeholder-password": "Mot de passe",
                connect: "Se connecter",
                register: "CRÉER UN COMPTE",
                "placeholder-lastname": "Nom",
                "placeholder-firstname": "Prénom",
                "placeholder-dh7": "DH7 ID (ex: adamsdhaiti@dh7.tf)",
                "placeholder-age": "Âge",
                "create-account": "REJOINDRE D'H7",
                "back-to-login": "RETOUR",
                "search-placeholder": "Rechercher dans D'H7...",
                "personal-tfid": "TFID Sécurisé",
                language: "LANGUE",
                logout: "SE DÉCONNECTER",
                close: "ANNULER",
                "message-placeholder": "Écrire un message...",
                no_users: "Pas de personnes dans D'H7 encore.",
                no_results: "PAS TROUVÉ D'UTILISATEUR",
                start_chat: "Cliquez pour commencer à parler...",
                no_contacts: "Pas de contacts encore. Recherchez des personnes pour commencer à parler.",
                copy: "Copier",
                reply: "Répondre",
                copied: "Copié",
                you: "Vous",
                "image-message": "Image",
                "voice-message": "Message vocal",
                "file-message": "Fichier",
                "loading": "Patientez s'il vous plaît...",
                "upload_failed": "Échec de l'upload après plusieurs tentatives"
            },
            en: {
                logo: "D'H7",
                subtitle: "Digital HUB 7",
                "placeholder-tfid": "TFID or DH7",
                "placeholder-password": "Password",
                connect: "Login",
                register: "CREATE AN ACCOUNT",
                "placeholder-lastname": "Last Name",
                "placeholder-firstname": "First Name",
                "placeholder-dh7": "DH7 ID (ex: adamsdhaiti@dh7.tf)",
                "placeholder-age": "Age",
                "create-account": "JOIN D'H7",
                "back-to-login": "BACK",
                "search-placeholder": "Search in D'H7...",
                "personal-tfid": "Secure TFID",
                language: "LANGUAGE",
                logout: "LOGOUT",
                close: "CANCEL",
                "message-placeholder": "Type a message...",
                no_users: "No people in D'H7 yet.",
                no_results: "NO USER FOUND",
                start_chat: "Click to start talking...",
                no_contacts: "No contacts yet. Search for people to start talking.",
                copy: "Copy",
                reply: "Reply",
                copied: "Copied",
                you: "You",
                "image-message": "Image",
                "voice-message": "Voice Message",
                "file-message": "File",
                "loading": "Please wait...",
                "upload_failed": "Upload failed after several attempts"
            },
            es: {
                logo: "D'H7",
                subtitle: "Digital HUB 7",
                "placeholder-tfid": "TFID o DH7",
                "placeholder-password": "Contraseña",
                connect: "Conectar",
                register: "CREAR UNA CUENTA",
                "placeholder-lastname": "Apellido",
                "placeholder-firstname": "Nombre",
                "placeholder-dh7": "DH7 ID (ej: adamsdhaiti@dh7.tf)",
                "placeholder-age": "Edad",
                "create-account": "UNIRSE A D'H7",
                "back-to-login": "REGRESAR",
                "search-placeholder": "Buscar en D'H7...",
                "personal-tfid": "TFID Seguro",
                language: "IDIOMA",
                logout: "CERRAR SESIÓN",
                close: "CANCELAR",
                "message-placeholder": "Escribe un mensaje...",
                no_users: "No hay personas en D'H7 aún.",
                no_results: "NO SE ENCONTRÓ USUARIO",
                start_chat: "Haz clic para comenzar a hablar...",
                no_contacts: "No hay contactos aún. Busca personas para comenzar a hablar.",
                copy: "Copiar",
                reply: "Responder",
                copied: "Copiado",
                you: "Tú",
                "image-message": "Imagen",
                "voice-message": "Mensaje de voz",
                "file-message": "Archivo",
                "loading": "Por favor espere...",
                "upload_failed": "Fallo de carga después de varios intentos"
            }
        };

        // CONFIG & STATE
        // Voice Recording State
        let mediaRecorder = null;
        let audioChunks = [];
        let recordStartTime = 0;
        let recordTimerInterval = null;

        // --- INIT & AUTH ---
        if(user) {
            startApp();
        } else {
            navTo('scr-auth');
        }

        function startApp() {
            if (!user) return;
            document.getElementById('m-name').innerText = `${user.prenom} ${user.nom}`;
            document.getElementById('m-dh7').innerText = user.dh7;
            document.getElementById('m-tfid').innerText = user.tfid;
            document.getElementById('m-init').innerText = user.nom[0];
            changeLanguage(currentLanguage);
            handleRouting();
            setupNotifications();
            // Initialiser les écouteurs pour le bouton d'action (Mic/Send)
            initActionBtn();
            forceScrollRecalc(); // Initial scroll fix
        }

        // Scroll reflow fix for Android
        function forceScrollRecalc() {
            const containers = document.querySelectorAll('.scroll-container');
            containers.forEach(c => {
                c.style.overflowY = 'hidden';
                setTimeout(() => { c.style.overflowY = 'auto'; }, 100);
            });
        }
        window.addEventListener('resize', forceScrollRecalc);
        window.addEventListener('load', forceScrollRecalc);

        async function getUserByTfid(tfid) {
            try {
                const res = await fetch(`${API}/users`);
                if (!res.ok) throw new Error('Failed to fetch users');
                const users = await res.json();
                return users.find(u => u.tfid === tfid);
            } catch (e) {
                console.error(e);
                return null;
            }
        }

        async function getUserByIdentifier(identifier) {
            try {
                const res = await fetch(`${API}/users`);
                if (!res.ok) throw new Error('Failed to fetch users');
                const users = await res.json();
                return users.find(u => u.tfid === identifier || u.dh7 === identifier);
            } catch (e) {
                console.error(e);
                return null;
            }
        }

        async function openChatByIdentifier(identifier) {
            const peer = await getUserByIdentifier(identifier);
            if (peer) {
                openChat(peer);
            } else {
                alert("Itilizatè sa pa egziste.");
            }
        }

        async function login() {
            let id = document.getElementById('login-id').value.trim();
            if (!id.includes('@dh7.tf') && !id.startsWith('TF-')) {
                id += '@dh7.tf';
            }
            const pass = document.getElementById('login-pass').value;
            try {
                const res = await fetch(`${API}/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ identifier: id, password: pass })
                });
                if (!res.ok) throw new Error('Login failed');
                const data = await res.json();
                if(data.success) {
                    user = data.user;
                    localStorage.setItem('dh7_session', JSON.stringify(user));
                    startApp();
                } else { alert(data.error); }
            } catch(e) { alert("Sèvè a pa reponn"); }
        }

        async function register() {
            const nom = document.getElementById('reg-nom').value;
            const prenom = document.getElementById('reg-prenom').value;
            let dh7 = document.getElementById('reg-dh7').value.trim();
            if (!dh7.includes('@dh7.tf')) {
                dh7 += '@dh7.tf';
            }
            const age = parseInt(document.getElementById('reg-age').value);
            const pass = document.getElementById('reg-pass').value;
            if (!age) {
                alert(translations[currentLanguage].enter_age || "Antre laj ou");
                return;
            }
            try {
                const res = await fetch(`${API}/register`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nom, prenom, dh7, age, password: pass }) 
                });
                if (!res.ok) throw new Error('Registration failed');
                const result = await res.json();
                if(result.success) {
                    alert((translations[currentLanguage].account_created || "Kont ou kreye!") + " TFID: " + result.tfid);
                    toggleAuth();
                } else { alert(result.error); }
            } catch (e) {
                alert("Sèvè a pa reponn");
            }
        }

        function toggleAuth() {
            document.getElementById('login-form').classList.toggle('hidden');
            document.getElementById('reg-form').classList.toggle('hidden');
        }

        function logout() { localStorage.clear(); location.reload(); }

        // --- NAVIGATION ---
        function navTo(screenId, peerTfid = null) {
            document.querySelectorAll('.screen').forEach(s => {
                s.classList.remove('active', 'hidden-left', 'hidden-right');
                if (s.id === screenId) {
                    s.classList.add('active');
                } else {
                    s.classList.add('hidden-right');
                }
            });

            let path = '/';
            if (screenId === 'scr-chat' && activePeer) {
                path = `/${activePeer.tfid}`;
            } else if (screenId === 'scr-search') {
                path = '/cherche';
            } else if (screenId === 'scr-menu') {
                path = '/menu';
            } else if (screenId === 'scr-video') {
                path = '/videyo';
            } else if (screenId === 'scr-photo') {
                path = '/foto';
            }
            history.pushState({ screen: screenId, tfid: peerTfid }, '', path);

            if (screenId === 'scr-home') {
                loadContacts();
                homeInterval = setInterval(updateContacts, 3000);
            } else {
                if (homeInterval) clearInterval(homeInterval);
            }
            if (screenId === 'scr-search') {
                const searchInput = document.getElementById('search-q');
                if (searchInput) searchInput.focus();
            }
            if (screenId !== 'scr-chat') {
                if (chatInterval) clearInterval(chatInterval);
            }
            if (screenId === 'scr-chat' && peerTfid) {
                getUserByTfid(peerTfid).then(peer => {
                    if (peer) openChat(peer);
                });
            }
            forceScrollRecalc(); // Reflow after nav
        }

        window.onpopstate = (event) => {
            if (event.state) {
                navTo(event.state.screen, event.state.tfid);
            } else {
                navTo('scr-home');
            }
        };

        function handleRouting() {
            const path = window.location.pathname;
            if (path === '/' || path === '') {
                navTo('scr-home');
            } else if (path.startsWith('/TF-')) {
                const tfid = path.slice(1);
                navTo('scr-chat', tfid);
            } else if (path.startsWith('/cherche')) {
                navTo('scr-search');
            } else if (path === '/menu') {
                navTo('scr-menu');
            } else {
                navTo('scr-home');
            }
        }

        // --- CONTACTS & LIST ---
        async function loadContacts() {
            shownTfids.clear();
            const container = document.getElementById('contact-list');
            if (!container) return;
            container.innerHTML = '';
            let totalUnread = 0;
            try {
                const res = await fetch(`${API}/users`);
                if (!res.ok) throw new Error('Failed to fetch users');
                const users = await res.json();
                const promises = users.map(async u => {
                    if (u.tfid === user.tfid) return null;
                    try {
                        const msgsRes = await fetch(`${API}/messages`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: u.tfid })
                        });
                        if (!msgsRes.ok) throw new Error('Failed to fetch messages');
                        const messages = await msgsRes.json();
                        const hasConversation = messages.some(m => m.text !== 'ok');
                        if (!hasConversation) return null;
                        const lastNonOkMsg = [...messages].reverse().find(m => m.text !== 'ok');
                        const lastTimestamp = lastNonOkMsg ? new Date(lastNonOkMsg.time).getTime() : 0;
                        const prefix = lastNonOkMsg && lastNonOkMsg.from === user.tfid ? translations[currentLanguage].you + ' ' : '';
                        const lastMsgText = prefix + (lastNonOkMsg ? getMainMessage(lastNonOkMsg.text) : '');
                        const unread = getUnreadCount(messages, u.tfid);
                        totalUnread += unread;
                        const card = document.createElement('div');
                        card.className = "contact-card";
                        card.dataset.lastTimestamp = lastTimestamp;
                        card.innerHTML = `
                            <div class="avatar">${u.nom[0]}</div>
                            <div class="flex-1">
                                <div class="flex justify-between items-center">
                                    <span class="font-bold text-lg leading-tight truncate">${u.prenom} ${u.nom}</span>
                                    <span class="tfid text-[9px] text-zinc-700 font-mono tracking-tighter copyable" onclick="copyToClipboard('${u.tfid}')">${u.tfid}</span>
                                </div>
                                <p class="text-zinc-500 text-sm truncate">${lastMsgText.substring(0, 30)}${lastMsgText.length > 30 ? '...' : ''}</p>
                            </div>
                            ${unread > 0 ? `<span class="unread-badge">+${unread}</span>` : ''}
                        `;
                        addLongPressListeners(card, (x, y) => showContactPreview(u), () => openChat(u));
                        shownTfids.add(u.tfid);
                        return card;
                    } catch (e) {
                        console.error(e);
                        return null;
                    }
                });
                const contacts = await Promise.all(promises);
                const filteredContacts = contacts.filter(c => c !== null);
                filteredContacts.forEach(c => container.appendChild(c));
                sortContacts();
                if (filteredContacts.length === 0) {
                    const p = document.createElement('p');
                    p.className = "text-zinc-700 text-center mt-20 no-contacts";
                    p.textContent = translations[currentLanguage].no_contacts;
                    container.appendChild(p);
                }
                localStorage.setItem('totalUnread', totalUnread);
                updateAppBadge(totalUnread);
            } catch (e) {
                console.error(e);
            }
        }

        function sortContacts() {
            const container = document.getElementById('contact-list');
            if (!container) return;
            const cards = Array.from(container.querySelectorAll('.contact-card'));
            cards.sort((a, b) => (b.dataset.lastTimestamp || 0) - (a.dataset.lastTimestamp || 0));
            cards.forEach(card => container.appendChild(card));
        }

        function getUnreadCount(messages, fromTfid) {
            let unread = 0;
            messages.forEach((m, index) => {
                if (m.text === 'ok') return;
                if (m.from === fromTfid) {
                    let read = m.read;
                    for (let j = index + 1; j < messages.length; j++) {
                        if (messages[j].from !== fromTfid && messages[j].text !== 'ok') {
                            read = true;
                            break;
                        }
                    }
                    if (!read) unread++;
                }
            });
            return unread;
        }

        async function updateContacts() {
            const container = document.getElementById('contact-list');
            if (!container) return;
            const cards = Array.from(container.querySelectorAll('.contact-card'));
            let totalUnread = 0;
            await Promise.all(cards.map(async card => {
                const tfid = card.querySelector('.tfid').textContent;
                try {
                    const msgsRes = await fetch(`${API}/messages`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: tfid })
                    });
                    if (!msgsRes.ok) throw new Error('Failed to fetch messages');
                    const messages = await msgsRes.json();
                    const unread = getUnreadCount(messages, tfid);
                    totalUnread += unread;
                    let badge = card.querySelector('.unread-badge');
                    if (unread > 0) {
                        if (!badge) {
                            badge = document.createElement('span');
                            badge.className = 'unread-badge';
                            card.appendChild(badge);
                        }
                        badge.textContent = `+${unread}`;
                    } else if (badge) {
                        badge.remove();
                    }
                    const lastNonOkMsg = [...messages].reverse().find(m => m.text !== 'ok');
                    const lastTimestamp = lastNonOkMsg ? new Date(lastNonOkMsg.time).getTime() : 0;
                    card.dataset.lastTimestamp = lastTimestamp;
                    const prefix = lastNonOkMsg && lastNonOkMsg.from === user.tfid ? translations[currentLanguage].you + ' ' : '';
                    const lastMsgText = prefix + (lastNonOkMsg ? getMainMessage(lastNonOkMsg.text) : '');
                    const p = card.querySelector('p.text-zinc-500');
                    if (p) p.textContent = lastMsgText.substring(0, 30) + (lastMsgText.length > 30 ? '...' : '');
                } catch (e) {
                    console.error(e);
                }
            }));

            try {
                const res = await fetch(`${API}/users`);
                if (!res.ok) throw new Error('Failed to fetch users');
                const users = await res.json();
                const newPromises = users.map(async u => {
                    if (u.tfid === user.tfid || shownTfids.has(u.tfid)) return null;
                    try {
                        const msgsRes = await fetch(`${API}/messages`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: u.tfid })
                        });
                        if (!msgsRes.ok) throw new Error('Failed to fetch messages');
                        const messages = await msgsRes.json();
                        const hasConversation = messages.some(m => m.text !== 'ok');
                        if (!hasConversation) return null;
                        const lastNonOkMsg = [...messages].reverse().find(m => m.text !== 'ok');
                        const lastTimestamp = lastNonOkMsg ? new Date(lastNonOkMsg.time).getTime() : 0;
                        const prefix = lastNonOkMsg && lastNonOkMsg.from === user.tfid ? translations[currentLanguage].you + ' ' : '';
                        const lastMsgText = prefix + (lastNonOkMsg ? getMainMessage(lastNonOkMsg.text) : '');
                        const unread = getUnreadCount(messages, u.tfid);
                        totalUnread += unread;
                        const card = document.createElement('div');
                        card.className = "contact-card";
                        card.dataset.lastTimestamp = lastTimestamp;
                        card.innerHTML = `
                            <div class="avatar">${u.nom[0]}</div>
                            <div class="flex-1">
                                <div class="flex justify-between items-center">
                                    <span class="font-bold text-lg leading-tight truncate">${u.prenom} ${u.nom}</span>
                                    <span class="tfid text-[9px] text-zinc-700 font-mono tracking-tighter copyable" onclick="copyToClipboard('${u.tfid}')">${u.tfid}</span>
                                </div>
                                <p class="text-zinc-500 text-sm truncate">${lastMsgText.substring(0, 30)}${lastMsgText.length > 30 ? '...' : ''}</p>
                            </div>
                            ${unread > 0 ? `<span class="unread-badge">+${unread}</span>` : ''}
                        `;
                        addLongPressListeners(card, (x, y) => showContactPreview(u), () => openChat(u));
                        shownTfids.add(u.tfid);
                        return card;
                    } catch (e) {
                        console.error(e);
                        return null;
                    }
                });
                const newContacts = await Promise.all(newPromises);
                newContacts.filter(c => c).forEach(c => container.appendChild(c));
                sortContacts();

                const noContactsP = container.querySelector('.no-contacts');
                if (noContactsP && container.querySelectorAll('.contact-card').length > 0) {
                    noContactsP.remove();
                }
                localStorage.setItem('totalUnread', totalUnread);
                updateAppBadge(totalUnread);
            } catch (e) {
                console.error(e);
            }
        }

        function updateAppBadge(count) {
            if ('setAppBadge' in navigator) {
                navigator.setAppBadge(count);
            } else if ('clearAppBadge' in navigator && count === 0) {
                navigator.clearAppBadge();
            }
        }

        async function doSearch() {
            let q = document.getElementById('search-q').value.toLowerCase().trim();
            if(q.length < 2) {
                document.getElementById('search-results').innerHTML = '';
                return;
            }
            try {
                const res = await fetch(`${API}/users`);
                if (!res.ok) throw new Error('Failed to fetch users');
                const users = await res.json();
                let filtered = users.filter(u => (u.dh7.toLowerCase().includes(q) || u.tfid.toLowerCase().includes(q) || (u.nom + ' ' + u.prenom).toLowerCase().includes(q)) && u.tfid !== user.tfid);
                
                const container = document.getElementById('search-results');
                container.innerHTML = filtered.length ? "" : `<p class="text-center text-zinc-600 mt-10 tracking-widest font-bold">${translations[currentLanguage].no_results}</p>`;
                filtered.forEach(u => {
                    const div = document.createElement('div');
                    div.className = "contact-card";
                    div.innerHTML = `<div class="avatar">${u.nom[0]}</div><div><p class="font-bold text-lg">${u.prenom} ${u.nom}</p><p class="text-xs text-zinc-600 font-mono copyable" onclick="copyToClipboard('${u.dh7}')">${u.dh7}</p></div>`;
                    div.onclick = () => openChat(u);
                    container.appendChild(div);
                });
            } catch (e) {
                console.error(e);
            }
        }

        async function openChat(peer) {
            if (!peer) return;
            activePeer = peer;
            document.getElementById('chat-peer-name').innerText = `${peer.prenom} ${peer.nom}`;
            document.getElementById('chat-peer-tfid').innerText = peer.tfid;
            navTo('scr-chat');
            resetChatView();
            await loadInitialMessages(); // Load all existing at once
            try {
                const msgsRes = await fetch(`${API}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: activePeer.tfid })
                });
                if (!msgsRes.ok) throw new Error('Failed to fetch messages');
                const messages = await msgsRes.json();
                const unread = messages.filter(m => m.from === activePeer.tfid && !m.read && m.text !== 'ok').length;
                if (unread > 0) {
                    await fetch(`${API}/mark-read`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ sender_tfid: activePeer.tfid, receiver_tfid: user.tfid }) 
                    });
                    let totalUnread = parseInt(localStorage.getItem('totalUnread') || '0') - unread;
                    localStorage.setItem('totalUnread', totalUnread);
                    updateAppBadge(totalUnread);
                }
                lastViewed[peer.tfid] = Date.now();
                localStorage.setItem('lastViewed', JSON.stringify(lastViewed));
            } catch (e) {
                console.error(e);
            }
            chatInterval = setInterval(syncChatSilently, 3000);
            setupScrollListener();
        }

        async function loadInitialMessages() {
            if (!activePeer || !user) return;

            try {
                const res = await fetch(`${API}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: activePeer.tfid })
                });
                
                const messages = await res.json();
                const container = document.getElementById('chat-messages');
                
                // Filter non-'ok' messages
                const validMessages = messages.filter(m => m.text !== 'ok');

                if (validMessages.length > 0) {
                    const fragment = document.createDocumentFragment();
                    validMessages.forEach(m => {
                        const msgId = m.time + m.from;
                        displayedMessageIds.add(msgId);
                        const div = createMessageElement(m);
                        fragment.appendChild(div);
                    });
                    container.appendChild(fragment);
                    scrollToBottom();
                    updateCheckmarks(messages);
                    attachVoicePlayers();
                }
            } catch (e) {
                console.error(e);
            }
        }

        function createMessageElement(m) {
            const isMe = m.from === user.tfid;
            const div = document.createElement('div');
            div.className = `bubble ${isMe ? 'me' : 'them'}`;
            div.id = `msg-${m.time.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            let text = m.text;
            if (text.startsWith(REPLY_START)) {
                let pos = REPLY_START.length;
                const idEnd = text.indexOf(REPLY_END, pos);
                const id = text.substring(pos, idEnd);
                pos = idEnd + REPLY_END.length;
                const senderEnd = text.indexOf(REPLY_END, pos);
                const sender = text.substring(pos, senderEnd);
                pos = senderEnd + REPLY_END.length;
                const quoted = text.substring(pos, text.indexOf(REPLY_END, pos));
                pos = text.indexOf(REPLY_END, pos) + REPLY_END.length;
                const main = text.substring(pos).trim();
                const replyDiv = document.createElement('div');
                replyDiv.className = 'reply-bar';
                const nameSpan = document.createElement('span');
                nameSpan.className = 'reply-name';
                nameSpan.innerText = sender;
                replyDiv.appendChild(nameSpan);
                const textSpan = document.createElement('span');
                textSpan.className = 'reply-text';
                textSpan.innerHTML = renderReplyPreview(quoted);
                replyDiv.appendChild(textSpan);
                replyDiv.classList.add(sender === translations[currentLanguage].you ? 'reply-me' : 'reply-them');
                replyDiv.onclick = () => {
                    const original = document.getElementById('msg-' + id);
                    if (original) {
                        original.scrollIntoView({behavior: 'smooth'});
                    }
                };
                div.appendChild(replyDiv);
                const mainSpan = document.createElement('span');
                mainSpan.className = 'main-message';
                mainSpan.innerHTML = renderText(main);
                div.appendChild(mainSpan);
            } else {
                div.innerHTML = renderText(text);
            }
            
            if (isMe) {
                const status = document.createElement('span');
                status.className = 'status';
                status.innerText = '✓'; // Initial, updated later
                div.appendChild(status);
            }

            addMessageListeners(div, text);
            return div;
        }

        async function syncChatSilently() {
            if (!activePeer || !user) return;

            try {
                const res = await fetch(`${API}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: activePeer.tfid })
                });
                
                const messages = await res.json();
                const container = document.getElementById('chat-messages');
                
                // On filtre uniquement les messages qui ne sont pas "ok" 
                // ET qui n'ont pas encore été affichés (ceux qui n'existent pas dans notre Set)
                const newMessages = messages.filter(m => {
                    const msgId = m.time + m.from; // Identifiant unique basé sur temps + expéditeur
                    return m.text !== 'ok' && !displayedMessageIds.has(msgId);
                });

                if (newMessages.length > 0) {
                    // Détecter si l'utilisateur est en train de lire en haut
                    const isAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 150;

                    const fragment = document.createDocumentFragment();
                    newMessages.forEach(m => {
                        const msgId = m.time + m.from;
                        displayedMessageIds.add(msgId); // On le marque comme "existant"
                        
                        // Create element and add to fragment
                        const div = createMessageElement(m);
                        div.classList.add('animate-slide-in'); // Animation only for new
                        fragment.appendChild(div);
                    });
                    container.appendChild(fragment);

                    // On ne scrolle que si l'utilisateur n'est pas en train de remonter le chat
                    if (isAtBottom) {
                        scrollToBottom();
                    }
                    attachVoicePlayers();
                }
                
                // Mise à jour des status (Checkmarks) sans toucher au texte
                updateCheckmarks(messages);

            } catch (e) {
                // En silence total
            }
        }

        function resetChatView() {
            displayedMessageIds.clear(); // Vide le stockage local de la session
            document.getElementById('chat-messages').innerHTML = ''; // Vide l'écran
            // currentChatMessages = []; // Commenté si non utilisé
        }

        function renderReplyPreview(quoted) {
            if (quoted.startsWith(PUBLIC_URL)) {
                const filename = quoted.split('/').pop();
                const ext = filename.split('.').pop().toLowerCase();
                let preview = '';
                if (['jpeg','jpg','gif','png','heic'].includes(ext)) {
                    preview = `<img src="${quoted}" class="reply-preview-media">`;
                } else if (['mp4','mov','avi','mkv','hevc'].includes(ext)) {
                    preview = `<video src="${quoted}" class="reply-preview-media" muted></video>`;
                } else if (['mp3','wav','ogg','aac','m4a'].includes(ext)) {
                    preview = `<i class="fa-solid fa-microphone reply-preview-icon"></i>`;
                } else {
                    preview = `<i class="fa-solid fa-file reply-preview-icon"></i>`;
                }
                return preview;
            } else {
                const lines = quoted.split('\n');
                const displayText = lines[0] + (lines.length > 1 ? '•••' : '');
                return displayText;
            }
        }

        function updateCheckmarks(messages) {
            const container = document.getElementById('chat-messages');
            const bubbles = container.querySelectorAll('.bubble.me');
            bubbles.forEach((bubble, idx) => {
                const msgTime = bubble.id.replace('msg-', '').replace(/-/g, ':'); // Assume time is in id
                const msgIndex = messages.findIndex(m => m.time === msgTime && m.from === user.tfid);
                if (msgIndex === -1) return;
                const m = messages[msgIndex];
                let read = m.read;
                for (let j = msgIndex + 1; j < messages.length; j++) {
                    if (messages[j].from !== user.tfid && messages[j].text !== 'ok') {
                        read = true;
                        break;
                    }
                }
                const status = bubble.querySelector('.status');
                if (status) {
                    status.innerText = read ? '✓✓' : '✓';
                    if (read) status.classList.add('read');
                    else status.classList.remove('read');
                }
            });
        }

        function setupScrollListener() {
            const container = document.getElementById('chat-messages');
            if (!container) return;
            const scrollDownBtn = document.getElementById('scroll-down-btn');
            container.addEventListener('scroll', () => {
                const isScrolledUp = container.scrollHeight - container.scrollTop - container.clientHeight > 50;
                scrollDownBtn.classList.toggle('hidden', !isScrolledUp);
            });
        }

        function scrollToBottom() {
            const d = document.getElementById('chat-messages');
            d.scrollTo({ top: d.scrollHeight, behavior: 'smooth' });
        }

        function getMainMessage(text) {
            if (text.startsWith(REPLY_START)) {
                let pos = REPLY_START.length;
                pos = text.indexOf(REPLY_END, pos) + REPLY_END.length;
                pos = text.indexOf(REPLY_END, pos) + REPLY_END.length;
                pos = text.indexOf(REPLY_END, pos) + REPLY_END.length;
                return text.substring(pos).trim();
            }
            return text.trim();
        }

        function addMessageListeners(bubble, text) {
            addLongPressListeners(bubble, (x, y) => showCopyMenu(x, y, text, bubble));
            let touchStartX = 0;
            bubble.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
            });
            bubble.addEventListener('touchend', (e) => {
                const touchEndX = e.changedTouches[0].clientX;
                const deltaX = touchEndX - touchStartX;
                if (deltaX > 50) { // Swipe right to reply
                    const isMe = bubble.classList.contains('me');
                    const sender = isMe ? translations[currentLanguage].you : document.getElementById('chat-peer-name').innerText;
                    const messageId = bubble.id.replace('msg-', '');
                    replyToMessage(getMainMessage(text), sender, messageId);
                }
            });
        }

        async function sendMessage() {
            const input = document.getElementById('msg-input');
            let text = input.value.trim();
            if(!text || !activePeer) return;
            if (replyingTo) {
                text = REPLY_START + replyingTo.id + REPLY_END + replyingTo.sender + REPLY_END + replyingTo.quoted + REPLY_END + '\n\n' + text;
                replyingTo = null;
                cancelReply();
            }
            input.value = "";
            input.style.height = 'auto';
            try {
                await fetch(`${API}/send`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sender_tfid: user.tfid, receiver_tfid: activePeer.tfid, message: text }) 
                });
                syncChatSilently();
            } catch (e) {
                console.error(e);
                alert("Mesaj pa ale.");
            }
        }

        function replyToMessage(quoted, sender, messageId) {
            replyingTo = {id: messageId, sender: sender, quoted: quoted};
            const preview = document.getElementById('reply-preview');
            const replyText = document.getElementById('reply-content');
            const mediaPreview = document.getElementById('reply-media-preview');
            mediaPreview.innerHTML = '';
            if (quoted.startsWith(PUBLIC_URL)) {
                const ext = quoted.split('.').pop().toLowerCase();
                if (['jpeg','jpg','gif','png','heic'].includes(ext)) {
                    mediaPreview.innerHTML = `<img src="${quoted}" class="reply-preview-media">`;
                } else if (['mp4','mov','avi','mkv','hevc'].includes(ext)) {
                    mediaPreview.innerHTML = `<video src="${quoted}" class="reply-preview-media" muted></video>`;
                } else if (['mp3','wav','ogg','aac','m4a'].includes(ext)) {
                    mediaPreview.innerHTML = `<i class="fa-solid fa-microphone reply-preview-icon"></i>`;
                } else {
                    mediaPreview.innerHTML = `<i class="fa-solid fa-file reply-preview-icon"></i>`;
                }
            } else {
                replyText.textContent = quoted.substring(0, 50) + (quoted.length > 50 ? ' •••' : '');
            }
            preview.classList.remove('hidden');
            const input = document.getElementById('msg-input');
            input.focus();
        }

        function cancelReply() {
            replyingTo = null;
            const preview = document.getElementById('reply-preview');
            if (preview) preview.classList.add('hidden');
        }

        function autoResize(el) {
            el.style.height = 'auto';
            el.style.height = el.scrollHeight + 'px';
        }

        async function setupNotifications() {
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                try {
                    const permission = await Notification.requestPermission();
                    if (permission !== 'granted') return;
                    const registration = await navigator.serviceWorker.ready;
                    const subscription = await registration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey: urlB64ToUint8Array('BFbcgVOdhydPHrXNgaelinKRIj4wUqTzLi13smhuzuzlWE_0F0evS2UxPm3fu-_gdVwNc5o3ursVFTKayf1Mndc') // Remplace par la clé VAPID publique du serveur
                    });
                    await fetch(`${API}/subscribe`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ tfid: user.tfid, subscription: subscription })
                    });
                } catch (e) {
                    console.error('Notification setup failed:', e);
                }
            }
        }

        function urlB64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        // --- CORE: MEDIA RENDERING & UTILS ---
        
        function renderText(text) {
            // Détection URL from workers.dev
            if (text.startsWith(PUBLIC_URL)) {
                const filename = text.split('/').pop();
                const ext = filename.split('.').pop().toLowerCase();
                if (['jpeg','jpg','gif','png','heic'].includes(ext)) {
                    return `<div class="media-content" onclick="openFullscreen('${text}', 'image')"><img src="${text}" loading="lazy" alt="${filename}" onerror="this.onerror=null; this.src=''; this.alt='${translations[currentLanguage]["loading"]}';" /></div>`;
                } else if (['mp4','mov','avi','mkv','hevc'].includes(ext)) {
                    return `<div class="media-content" onclick="openFullscreen('${text}', 'video')"><video src="${text}" playsinline muted preload="metadata" poster="${text}#t=0.1" onerror="this.onerror=null; this.poster=''; this.alt='${translations[currentLanguage]["loading"]}';"></video></div>`;
                } else if (['mp3','wav','ogg','aac','m4a'].includes(ext)) {
                    return renderCustomVoicePlayer(text);
                } else {
                    // Autres fichiers: afficher nom et lien
                    return `<div class="file-preview" onclick="openFileInNewTab('${text}')"><i class="fa-solid fa-file file-icon"></i><span class="file-link">${filename}</span></div>`;
                }
            }
            
            // Liens URL standards
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return text.replace(urlRegex, '<a href="$1" target="_blank" class="underline text-blue-300">$1</a>');
        }

        function renderCustomVoicePlayer(src) {
            const playerId = `voice-${Math.random().toString(36).substr(2,9)}`;
            return `
                <div class="voice-player" data-src="${src}" id="${playerId}">
                    <svg class="play-pause" viewBox="0 0 24 24" fill="white">
                        <path d="M8 5v14l11-7z"/> <!-- Play -->
                    </svg>
                    <div class="progress-bar">
                        <div class="wave-form"></div>
                        <div class="seeker" style="left: 0%;"></div>
                    </div>
                    <span class="time-display">0:00</span>
                    <span class="speed-control">1x</span>
                </div>
            `;
        }

        function attachVoicePlayers() {
            document.querySelectorAll('.voice-player:not(.attached)').forEach(player => {
                player.classList.add('attached');
                const audio = new Audio(player.dataset.src);
                const playPause = player.querySelector('.play-pause');
                const progressBar = player.querySelector('.progress-bar');
                const waveForm = player.querySelector('.wave-form');
                const seeker = player.querySelector('.seeker');
                const timeDisplay = player.querySelector('.time-display');
                const speedControl = player.querySelector('.speed-control');
                let isPlaying = false;
                let isSeeking = false;
                let speeds = ['1x', '1.5x', '2x'];
                let currentSpeedIndex = 0;
                audio.playbackRate = 1;

                // Generate ~30 wave bars with varying heights
                for (let i = 0; i < 30; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    bar.style.height = `${Math.random() * 80 + 20}%`; // Vary 20-100%
                    waveForm.appendChild(bar);
                }
                const waveBars = waveForm.querySelectorAll('.wave-bar');

                speedControl.addEventListener('click', () => {
                    currentSpeedIndex = (currentSpeedIndex + 1) % speeds.length;
                    speedControl.textContent = speeds[currentSpeedIndex];
                    audio.playbackRate = parseFloat(speeds[currentSpeedIndex]);
                });

                playPause.addEventListener('click', () => {
                    if (isPlaying) {
                        audio.pause();
                        playPause.innerHTML = '<path d="M8 5v14l11-7z"/>';
                    } else {
                        audio.play();
                        playPause.innerHTML = '<path d="M6 4h4v16H6zM14 4h4v16h-4z"/>';
                    }
                    isPlaying = !isPlaying;
                });

                audio.addEventListener('timeupdate', () => {
                    if (!isSeeking) {
                        const progress = (audio.currentTime / audio.duration) * 100;
                        seeker.style.left = `${progress}%`;
                        timeDisplay.textContent = formatTime(audio.currentTime);
                        updateWaveProgress(progress);
                    }
                });

                audio.addEventListener('loadedmetadata', () => {
                    timeDisplay.textContent = formatTime(audio.duration);
                });

                audio.addEventListener('ended', () => {
                    isPlaying = false;
                    playPause.innerHTML = '<path d="M8 5v14l11-7z"/>';
                    seeker.style.left = '0%';
                    timeDisplay.textContent = formatTime(audio.duration);
                    updateWaveProgress(0);
                });

                progressBar.addEventListener('touchstart', startSeek);
                progressBar.addEventListener('mousedown', startSeek);

                function startSeek(e) {
                    isSeeking = true;
                    seek(e);
                    const moveEvent = 'ontouchstart' in window ? 'touchmove' : 'mousemove';
                    const endEvent = 'ontouchstart' in window ? 'touchend' : 'mouseup';
                    document.addEventListener(moveEvent, seek);
                    document.addEventListener(endEvent, endSeek);
                }

                function seek(e) {
                    const touch = e.touches ? e.touches[0] : e;
                    const rect = progressBar.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const progress = Math.min(1, Math.max(0, x / rect.width));
                    seeker.style.left = `${progress * 100}%`;
                    audio.currentTime = progress * audio.duration;
                    updateWaveProgress(progress * 100);
                }

                function endSeek() {
                    isSeeking = false;
                    const moveEvent = 'ontouchstart' in window ? 'touchmove' : 'mousemove';
                    const endEvent = 'ontouchstart' in window ? 'touchend' : 'mouseup';
                    document.removeEventListener(moveEvent, seek);
                    document.removeEventListener(endEvent, endSeek);
                    if (isPlaying) audio.play();
                }

                function updateWaveProgress(progress) {
                    const progressedCount = Math.floor((progress / 100) * waveBars.length);
                    waveBars.forEach((bar, index) => {
                        if (index < progressedCount) {
                            bar.classList.add('progressed');
                        } else {
                            bar.classList.remove('progressed');
                        }
                    });
                }

                function formatTime(seconds) {
                    const m = Math.floor(seconds / 60);
                    const s = Math.floor(seconds % 60);
                    return `${m}:${s < 10 ? '0' : ''}${s}`;
                }
            });
        }

        function openFullscreen(dataUrl, type) {
            const fs = document.getElementById('fs-media');
            let content = '';
            if (type === 'image') {
                content = `<img src="${dataUrl}" alt="Fullscreen Image" id="zoom-img" />`;
            } else if (type === 'video') {
                content = `<video src="${dataUrl}" controls autoplay playsinline loop></video>`;
            } else if (type === 'audio') {
                content = `<audio src="${dataUrl}" controls autoplay></audio>`;
            }
            fs.innerHTML = content + `<svg class="fullscreen-close w-8 h-8" onclick="closeFullscreen()" fill="none" stroke="white" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>`;
            fs.classList.remove('hidden');
            history.pushState({ screen: type === 'video' ? 'scr-video' : 'scr-photo' }, '', `/${type === 'video' ? 'videyo' : 'foto'}`);
            if (type === 'image') {
                enablePinchZoom();
            }
        }

        function enablePinchZoom() {
            const img = document.getElementById('zoom-img');
            let scale = 1;
            let initialScale = 1;
            let initialDistance = 0;
            const fs = document.getElementById('fs-media');
            fs.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    initialScale = scale;
                    e.preventDefault();
                }
            });
            fs.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                    scale = initialScale * (dist / initialDistance);
                    img.style.transform = `scale(${scale})`;
                    e.preventDefault();
                }
            });
        }

        function closeFullscreen() {
            const fs = document.getElementById('fs-media');
            fs.classList.add('hidden');
            fs.innerHTML = '';
            history.back();
        }

        function openFileInNewTab(dataUrl) {
            const newTab = window.open();
            newTab.document.write('<iframe src="' + dataUrl + '" frameborder="0" style="border:0; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen></iframe>');
        }

        // --- INPUT & SENDING LOGIC ---

        function handleInput(el) {
            // Auto resize
            el.style.height = 'auto';
            el.style.height = (el.scrollHeight) + 'px';
            updateActionButton();
        }

        // Gestion Bouton Dynamique (Micro vs Send)
        function initActionBtn() {
            const btn = document.getElementById('action-btn');
            if (!btn) return;
            const icon = document.getElementById('action-icon');
            const input = document.getElementById('msg-input');

            // MOUSE / TOUCH EVENTS pour l'enregistrement
            btn.addEventListener('mousedown', startRecording);
            btn.addEventListener('touchstart', startRecording, { passive: true });
            
            btn.addEventListener('mouseup', endRecordingOrSend);
            btn.addEventListener('touchend', endRecordingOrSend, { passive: true });
        }

        function updateActionButton() {
            const input = document.getElementById('msg-input');
            if (!input) return;
            const btn = document.getElementById('action-btn');
            const icon = document.getElementById('action-icon');
            
            if(input.value.trim().length > 0) {
                // Mode SEND
                btn.classList.remove('mic-mode');
                icon.className = "fa-solid fa-paper-plane";
            } else {
                // Mode MIC
                btn.classList.add('mic-mode');
                icon.className = "fa-solid fa-microphone";
            }
        }

        // --- VOICE RECORDER LOGIC ---
        let longPressTimer;
        let isRecording = false;

        async function startRecording(e) {
            const input = document.getElementById('msg-input');
            if(input.value.trim().length > 0) return; // Si texte, ignorer le micro

            e.preventDefault(); // Empêcher le focus perdu
            longPressTimer = setTimeout(async () => {
                isRecording = true;
                // UI Update
                document.getElementById('msg-input').classList.add('hidden');
                document.getElementById('recording-ui').classList.remove('hidden');
                
                // Start Logic
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                    mediaRecorder.start();
                    startTimer();
                } catch(err) {
                    alert("Microphone non autorisé");
                    cancelRecording();
                }
            }, 300); // 300ms long press
        }

        async function endRecordingOrSend(e) {
            clearTimeout(longPressTimer);
            const input = document.getElementById('msg-input');
            
            // Cas 1: C'était un clic court sur "Envoyer" (car il y a du texte)
            if(input.value.trim().length > 0) {
                sendMessage();
                return;
            }

            // Cas 2: C'était un enregistrement vocal
            if(isRecording) {
                stopTimer();
                isRecording = false;
                document.getElementById('msg-input').classList.remove('hidden');
                document.getElementById('recording-ui').classList.add('hidden');
                
                if(mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/mp3' });
                        document.getElementById('upload-loading').classList.remove('hidden');
                        try {
                            await uploadFile(audioBlob, `voice_${Date.now()}.mp3`, 'audio/mp3');
                        } finally {
                            document.getElementById('upload-loading').classList.add('hidden');
                        }
                    };
                }
            } else {
                // Clic court sur le micro sans enregistrer -> message d'aide ou rien
                // alert("Maintenez pour parler");
            }
        }
        
        function cancelRecording() {
            isRecording = false;
            stopTimer();
            if(mediaRecorder) mediaRecorder.stop();
            document.getElementById('msg-input').classList.remove('hidden');
            document.getElementById('recording-ui').classList.add('hidden');
        }

        function startTimer() {
            let sec = 0;
            const timerEl = document.getElementById('rec-timer');
            recordTimerInterval = setInterval(() => {
                sec++;
                let m = Math.floor(sec/60);
                let s = sec%60;
                timerEl.innerText = `${m}:${s<10?'0':''}${s}`;
            }, 1000);
        }
        function stopTimer() { clearInterval(recordTimerInterval); document.getElementById('rec-timer').innerText = "0:00"; }

        // --- FILE ATTACHMENT ---
        async function handleFileSelect(input) {
            const file = input.files[0];
            if(!file) return;
            
            document.getElementById('upload-loading').classList.remove('hidden');
            try {
                await uploadFile(file, file.name, file.type);
            } finally {
                document.getElementById('upload-loading').classList.add('hidden');
            }
            input.value = "";
        }

        async function uploadFile(file, filename, type) {
            let attempts = 0;
            const maxAttempts = 5;
            while (attempts < maxAttempts) {
                try {
                    const uniqueName = `${crypto.randomUUID()}_${filename}`;
                    const uploadRes = await fetch(`${UPLOAD_URL}/${uniqueName}`, {
                        method: 'PUT',
                        headers: {'Content-Type': type},
                        body: file
                    });
                    if (uploadRes.ok) {
                        const url = await uploadRes.text();
                        let content = url;
                        if (replyingTo) {
                            content = REPLY_START + replyingTo.id + REPLY_END + replyingTo.sender + REPLY_END + replyingTo.quoted + REPLY_END + '\n\n' + url;
                            replyingTo = null;
                            cancelReply();
                        }
                        await postData(content);
                        syncChatSilently();
                        return;
                    } else {
                        attempts++;
                    }
                } catch(e) {
                    console.error(e);
                    attempts++;
                }
            }
            alert(translations[currentLanguage]["upload_failed"]);
        }

        // --- SEND API ---
        async function sendMedia(base64Data, filename) {
            // Dans ce système simplifié, on envoie le base64 comme texte.
            // Le rendu sera géré par renderText().
            await postData(base64Data);
            syncChatSilently();
        }

        async function postData(content) {
            try {
                await fetch(`${API}/send`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        sender_tfid: user.tfid,
                        receiver_tfid: activePeer.tfid,
                        message: content
                    })
                });
            } catch(e) { console.error("Send failed", e); }
        }

        // --- UI OVERLAYS ---
        function showLang() {
            document.getElementById('backdrop').classList.add('show');
            document.getElementById('lang-sheet').classList.add('show');
        }
        function closeOverlays() {
            document.getElementById('backdrop').classList.remove('show');
            document.getElementById('lang-sheet').classList.remove('show');
        }
        function changeLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('language', lang);
            document.querySelectorAll('[data-key]').forEach(el => {
                const key = el.dataset.key;
                if (translations[lang][key]) {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        el.placeholder = translations[lang][key];
                    } else {
                        el.innerText = translations[lang][key];
                    }
                }
            });
            closeOverlays();
            if (document.querySelector('.no-contacts')) {
                document.querySelector('.no-contacts').textContent = translations[lang].no_contacts;
            }
        }

        let currentText = '';
        function showCopyMenu(x, y, text) {
            currentText = text;
            const menu = document.getElementById('copy-menu');
            menu.style.left = `${x - 40}px`;
            menu.style.top = `${y + 10}px`;
            menu.classList.remove('hidden');
            document.getElementById('copy-btn').innerText = translations[currentLanguage].copy;
            document.getElementById('reply-btn').innerText = translations[currentLanguage].reply;
            document.getElementById('copy-btn').onclick = () => {
                copyToClipboard(text);
                hideCopyMenu();
            };
            document.getElementById('reply-btn').onclick = () => {
                replyToMessage(text, document.getElementById('chat-messages').lastChild.classList.contains('me') ? translations[currentLanguage].you : document.getElementById('chat-peer-name').innerText);
                hideCopyMenu();
            };
            document.addEventListener('touchstart', handleOutsideTouch);
            document.addEventListener('mousedown', handleOutsideTouch);
        }

        function hideCopyMenu() {
            document.getElementById('copy-menu').classList.add('hidden');
            document.removeEventListener('touchstart', handleOutsideTouch);
            document.removeEventListener('mousedown', handleOutsideTouch);
        }

        function handleOutsideTouch(e) {
            if (!document.getElementById('copy-menu').contains(e.target)) {
                hideCopyMenu();
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                const toast = document.createElement('div');
                toast.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-50 text-white px-4 py-2 rounded-full';
                toast.textContent = translations[currentLanguage].copied;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 1500);
            }).catch(e => console.error(e));
        }

        function addLongPressListeners(element, longPressCallback, shortPressCallback = null) {
            let longPressTimer;
            let isLongPress = false;
            let startX, startY;
            let isTouch = false;

            const start = (e) => {
                isTouch = e.type === 'touchstart';
                const pos = isTouch ? e.touches[0] : e;
                startX = pos.clientX;
                startY = pos.clientY;
                isLongPress = false;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    longPressCallback(startX, startY);
                }, 500);
            };

            const end = (e) => {
                clearTimeout(longPressTimer);
                if (!isLongPress && shortPressCallback) {
                    shortPressCallback();
                }
            };

            const move = (e) => {
                const pos = isTouch ? e.touches[0] : e;
                if (Math.abs(pos.clientX - startX) > 10 || Math.abs(pos.clientY - startY) > 10) {
                    clearTimeout(longPressTimer);
                }
            };

            element.addEventListener('touchstart', start, { passive: true });
            element.addEventListener('touchend', end, { passive: true });
            element.addEventListener('touchmove', move, { passive: true });
            element.addEventListener('mousedown', start);
            element.addEventListener('mouseup', end);
            element.addEventListener('mousemove', move);
            element.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
        }

        async function showContactPreview(peer) {
            if (!peer) return;
            document.getElementById('preview-overlay').classList.remove('hidden');
            const preview = document.getElementById('contact-preview');
            preview.classList.remove('hidden');
            preview.innerHTML = `
                <h3 class="font-bold text-lg mb-1">${peer.prenom} ${peer.nom}</h3>
                <p class="text-[10px] text-zinc-500 mb-4 copyable" onclick="copyToClipboard('${peer.tfid}')">${peer.tfid}</p>
                <div class="mini-chat"></div>
            `;
            try {
                const res = await fetch(`${API}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user1_tfid: user.tfid, user2_tfid: peer.tfid })
                });
                if (!res.ok) throw new Error('Failed to fetch messages');
                const messages = await res.json();
                const msgDiv = preview.querySelector('.mini-chat');
                const last7 = messages.filter(m => m.text !== 'ok').slice(-7);
                last7.forEach(m => {
                    const isMe = m.from === user.tfid;
                    const div = document.createElement('div');
                    div.className = `mini-bubble ${isMe ? 'me' : 'them'}`;
                    div.innerText = getMainMessage(m.text);
                    msgDiv.appendChild(div);
                });
            } catch (e) {
                console.error(e);
            }
        }

        function hideContactPreview() {
            document.getElementById('preview-overlay').classList.add('hidden');
            const preview = document.getElementById('contact-preview');
            preview.classList.add('hidden');
            preview.innerHTML = '';
        }

        document.addEventListener('gesturestart', function (e) { e.preventDefault(); });
        document.addEventListener('touchmove', function (e) { if (e.scale !== 1) { e.preventDefault(); } } , { passive: false });
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('/sw.js').then(function(registration) {
                    console.log('Service Worker registered');
                }).catch(function(err) {
                    console.log('Service Worker registration failed: ', err);
                });
            });
        }

        const msgInput = document.getElementById('msg-input');
        if (msgInput) {
            msgInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const start = msgInput.selectionStart;
                    msgInput.value = msgInput.value.substring(0, start) + '\n' + msgInput.value.substring(start);
                    msgInput.selectionStart = msgInput.selectionEnd = start + 1;
                    autoResize(msgInput);
                }
            };
        }

        changeLanguage(currentLanguage);
    </script>
</body>
</html>
